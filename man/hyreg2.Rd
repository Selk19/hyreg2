% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hyreg2.R
\name{hyreg2}
\alias{hyreg2}
\title{hyreg2: function for model estimation for EQ5D valueset data}
\usage{
hyreg2(
  formula,
  data,
  type,
  type_cont,
  type_dich,
  k = 1,
  control = NULL,
  stv = NULL,
  offset = NULL,
  opt_method = "BFGS",
  optimizer = "optim",
  lower = -Inf,
  upper = Inf,
  latent = "both",
  id_col = NULL,
  classes_only = FALSE,
  variables_both = NULL,
  variables_dich = NULL,
  variables_cont = NULL,
  ...
)
}
\arguments{
\item{formula}{linear model formula, using “| x” will include a grouping variable x, see details}

\item{data}{a dataframe containing the data, see details}

\item{type}{either the name of the column in data containing an indicator whether that datapoint (row)
contains continuous or dichotomous data as character, or the whole vector containing the indicator, see details}

\item{type_cont}{value of type referring to continuous data, see details}

\item{type_dich}{value of type referring to dichotomous data, see details}

\item{k}{numeric, number of latent classes to be estimated via flexmix::flexmix}

\item{control}{control vector for flexmix::flexmix}

\item{stv}{named vector or list of named vectors containing start values for all coefficients
formula, including sigma and theta, see details}

\item{offset}{offset as in flexmix::flexmix}

\item{opt_method}{charachter, optimization method to be used in optimizer, default = "BFGS"}

\item{optimizer}{charachter,optimizer to be used in bbmle::mle2, default = "optim"}

\item{lower}{numeric, lower bound for censored data, default = INF. If this is used, opt_method must be set to "L-BFGS-B",}

\item{upper}{numeric, upper bound for censored data, default = INF. If this is used, opt_method must be set to "L-BFGS-B",}

\item{latent}{charachter,data type to use in component identification, must be one of "both", "cont" or "dich",
default = “both”,  see details}

\item{id_col}{character, name of the grouping variable, only needed if latent != "both”, see details}

\item{classes_only}{logical, default FALSE, indicates whether the function should perform only
classification, rather than both classification and model estimation, only possible for latent != "both",
 see datails}

\item{variables_both}{character vector; variables to be fitted on both continuous and dichotomous data.
If not specified, all variables from formula are used. If provided and not all variables from formula
are included, variables_cont and variables_dich must be provided as well, while one of them can be NULL,
 see details.}

\item{variables_dich}{character vactor; variables to be fitted only on dichotomous data, if provided,
variables_both and variables_cont must be provided as well.}

\item{variables_cont}{character vector; variables to be fitted only on continous data. If provided,
variables_both and variables_dich must be provided as well.}

\item{...}{additional arguments for flexmix::flexmix or bbmle::mle2}
}
\value{
model object of type flexmix or list of model objects of type flexmix
}
\description{
Estimation of hybrid model for EQ-5D data
}
\details{
formula: a typical R formula of the form y ~ x1 + x2 + … should be provided.
Additionally, it is possible to include a grouping variable for repeated measures by using
“| xg” where xg is the column containing the group-memberships. The resulting formula will look
like this:  y ~ x1 + x2 +… | xg.  In flexmix, this is called the concomitant variable specification:
the  model is fit conditional on grouping, so that all observations with the same group are treated
as belonging together when computing likelihood contributions. One possible grouping variable can be
an id number to identify answers by the same participants. We highly recommend using a grouping variable,
 since otherwise the algorithm for k = 2 tends to classify all continuous data into one estimated class
and all dichotomous data into the other.


data: a dataframe having the following columns: all independent variables (x)
 and the dependent variable y used in formula, one column for the grouping variable xg if grouping
 should be used, e.g. id numbers of participants with repeated measurements, one column indicating
 if the observations belongs to continuous or dichotomous data with the entries type_cont
  and type_dich (e.g., for a column called "type" with the entries "TTO" for continuous datapoints
   and "DCE" for dichotomous datapoints, type_cont will be "TTO" and type_dich will be "DCE").
   One row should match one observation (one datapoint).


start values (stv): if the same start values are to be used for all latent classes,
the given start values must be a named vector. Otherwise (if different start values are assumed for
 each latent class), a list of named vectors should be used . In this case, there must be one entry
  in the list for each latent class.  Each start value vector must include start values for sigma and
  theta. Currently, it is necessary to use the names "sigma" and "theta" for these values.
  If users are unsure for which variables start values must be provided, this can be checked by
   calling colnames(model.matrix(formula,data)). In this call, the formula should not include the
   grouping variable.


latent, id_col, classes_only: in some situations, it can be useful to identify the latent classes on
only one type of data while estimating the model parameters on both types of data. In such cases,
the input variable latent can be used to specify on which type of data the classification should be done.
 If “cont” or “dich” is used, the input parameter id_col must be specified and gives the name,
 i.e. a character string, of the grouping variable for classification. Some groups may be removed from
 the data, since they have only continuous or only dichotomous observations. Then in a first step,
 a model is estimated only on the continuous/dichotomous data and the achieved classification is stored.
 In a next step, model parameters are estimated separately for each identified class on both types of data
 using this classification. The output object of hyreg2 in this case is a list of k models.
 Additionally, at position k+1 of the list, a data frame containing the corresponding classifications
 from the first step is returned. Each element k in the list contains the estimated parameters for one
 of the latent classes. When setting the input variable classes_only to TRUE, the second step is left
 out and the estimated classes from step one are given as output.


Variables_both, variables_cont, variables_dich: It is possible to specify partial coefficients,
 which are used only on continuous or dichotomous data.
 Example:  Suppose different models should be specified for continuous and dichotomous  data:
 • Model continuous data: y ~  x1 + x3
 • Model dichotomous data: y ~  x1 + x2
 The formula input to hyreg2 must then include all parameters that occur in either model:
  y ~ x1 + x2 + x3
 The assignment of parameters to data types is then achieved via the input arguments variables_both,
  variables_cont, and variables_dich:
 variables_both = “x1”,
 variables_cont = “x3” and
 variables_dich = “x2”.
 Every variable included in the provided formula (except the grouping variable ) must appear in exactly
  one of these vectors. One of the variables_ vectors can also be NULL, if no variables should be used only on this type of the data.
}
\examples{

formula <- y ~  -1 + x1 + x2 + x3 | id

k <- 2
stv <- setNames(c(0.2,0,1,1,1),c(colnames(simulated_data_norm)[3:5],c("sigma","theta")))
control = list(iter.max = 1000, verbose = 4)
rm(counter)
mod <- hyreg2(formula = formula,
                    data =  simulated_data_norm,
                    type =  simulated_data_norm$type, # also "type" would work
                    stv = stv,
                    k = k,
                    type_cont = "TTO",
                    type_dich = "DCE_A",
                    opt_method = "L-BFGS-B",
                    control = control,
                    latent = "cont",
                    id_col = "id"
)
summary_hyreg2(mod)
}
\author{
Svenja Elkenkamp, Kim Rand & John Grosser
}
